name: Build and Deploy
concurrency: build_and_deploy_${{ github.ref_name }}

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Deploy environment"
        required: true
        type: choice
        default: review
        options:
          - review
          - test
          - production
      docker-image-tag:
        description: "Docker image tag to deploy (optional)"
        required: true
        type: string
      pull-request-number:
        description: "Pull request number (required for review environment)"
        required: false
        type: string

  push:
    branches:
      - main

  pull_request:
    branches:
      - main
    types: [opened, reopened, synchronize, labeled]

env:
  TERRAFORM_BASE: terraform/application
  HEALTHCHECK_CMD: "healthcheck"

jobs:

  # ---------------------------
  # BUILD
  # ---------------------------
  build:
    name: Build
    if: ${{ github.event_name != 'workflow_dispatch' }}
    env:
      DOCKER_REPOSITORY: ghcr.io/dfe-digital/sap-public
    outputs:
      docker-image-tag: ${{ steps.build-image.outputs.tag }}
    permissions:
      packages: write
      pull-requests: write
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build and push docker image
        id: build-image
        uses: DFE-Digital/github-actions/build-docker-image@master
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          context: .
          docker-repository: ${{ env.DOCKER_REPOSITORY }}
          max-cache: true
          reuse-cache: true
          snyk-token: ${{ secrets.SNYK_TOKEN }}

  # ---------------------------
  # TESTS: UNIT, INTEGRATION, UI
  # ---------------------------
  test:
    name: Run Unit, Integration and UI Tests
    if: ${{ github.event_name != 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    needs: [build]

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Setup .NET 8
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "8.0.x"

      - name: Restore dependencies
        run: dotnet restore

      - name: Build solution
        run: dotnet build --configuration Debug

      - name: Restore .NET tools
        run: dotnet tool restore

      - name: Install Playwright browsers (.NET)
        run: pwsh ./Tests/SAPPub.Web.Tests/bin/Debug/net8.0/playwright.ps1 install
        
      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'
          cache-dependency-path: '**/package-lock.json'

      - name: build frontend assets
        working-directory: SAPPub.Web
        run: npm ci

      - name: Start MVC App
        run: |
          dotnet run --project ./SAPPub.Web/SAPPub.Web.csproj --urls "https://localhost:3000" &
        env:
          ASPNETCORE_ENVIRONMENT: Development

      - name: Wait for MVC App to be ready
        run: npx wait-on https://localhost:3000

      #- name: Run Unit Tests
      #  run: dotnet test ./SAPPub.Tests.Unit/SAPPub.Tests.Unit.csproj --no-build --logger trx /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura

      #- name: Run Integration Tests
      #  run: dotnet test ./SAPPub.Tests.Integration/SAPPub.Tests.Integration.csproj --no-build --logger trx /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura

      #- name: Run UI Tests
      #  run: dotnet test ./SAPPub.Tests.UI/SAPPub.Tests.UI.csproj --no-build --logger trx /p:CollectCoverage=true /p:CoverletOutputFormat=cobertura

      - name: Run All Tests with Coverage
        env:
          HEADED: 0
          PLAYWRIGHT_IGNORE_HTTPS_ERRORS: true
        run: |
          TEST_PROJECTS=$(find ./Tests -type f -name "*.Tests.csproj" | sort)

          for proj in $TEST_PROJECTS; do
            echo "=== Running tests in $proj ==="

            dotnet test "$proj" \
              --no-build \
              --configuration Debug \
              --results-directory "TestResults" \
              --logger "trx;LogFileName=$(basename "$proj" .csproj).trx" \
              --collect "XPlat Code Coverage"\
              /p:CollectCoverage=true \
              /p:CoverletOutputFormat=cobertura \
              /p:DeterministicReport=true \
              /p:UseSourceLink=true \
              /p:Exclude='[*]AspNetCoreGeneratedDocument.*%2c[*]AspNetCore.Views.*' \
              /p:ExcludeByAttribute='GeneratedCodeAttribute*%2cObsoleteAttribute*%2cExcludeFromCodeCoverage' \
              --verbosity normal
          done

      #- name: List artifacts
      #  if: ${{ always() }}
      #  run: |
      #    echo "Listing test-artifacts..."
      #    ls -R SAPPub.Tests.UI/test-artifacts || echo "No artifacts found"

      - name: Upload Test Result Files
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: "**/TestResults/**/*"
          retention-days: 5

      - name: Upload UI artifacts on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: ui-test-artifacts
          path: |
            **/test-artifacts/screenshots/**
            **/test-artifacts/videos/**
            **/test-artifacts/traces/**

      - name: Publish Test Results
        uses: dorny/test-reporter@v2
        if: always()
        with:
          reporter: 'dotnet-trx'
          path: "**/TestResults/**/*.trx"
          name: 'Test Results'

      - name: merge coverage files
        run: |
          dotnet tool install -g dotnet-coverage
          dotnet coverage merge --reports $(find Tests -name "coverage.cobertura.xml") -f cobertura -o coverage-results/coverage.xml

      - name: Generate Coverage Report
        uses: clearlyip/code-coverage-report-action@v6
        id: code_coverage_report_action
        if: ${{ github.actor != 'dependabot[bot]'}}
        with:
          filename: "coverage-results/coverage.xml"
          fail_on_negative_difference: true
          only_list_changed_files: true

      - name: Add Coverage PR Comment
        uses: marocchino/sticky-pull-request-comment@v2
        if: steps.code_coverage_report_action.outputs.file != '' && github.event_name == 'pull_request' && (success() || failure())
        with:
          recreate: true
          path: code-coverage-results.md

  # ---------------------------
  # REVIEW APP DEPLOYMENT (PR)
  # ---------------------------
  deploy-review-app:
    name: Deployment To Review
    concurrency: deploy_review_${{ github.event.pull_request.number }}
    if: ${{ github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'deploy') }}
    needs: [build, test]
    environment:
      name: review
      url: ${{ steps.deploy_review.outputs.environment_url }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      pull-requests: write

    env:
      AKS_RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}
      AKS_CLUSTER_NAME: ${{ secrets.AKS_CLUSTER_NAME }}

      KONDUIT_NAMESPACE: ${{ secrets.AKS_NAMESPACE }}
      KONDUIT_APP_NAME: ${{ secrets.KONDUIT_APP_NAME }}

    steps:
      - name: Deploy App to Review
        id: deploy_review
        uses: DFE-Digital/github-actions/deploy-to-aks@master
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          environment: review
          pr-number: ${{ github.event.pull_request.number }}
          sha: ${{ needs.build.outputs.docker-image-tag }}
          terraform-base: ${{ env.TERRAFORM_BASE }}
          healthcheck: ${{ env.HEALTHCHECK_CMD }}
          db-seed: false
          smoke-test: false

      # ---------------------------
      # REVIEW APP DATABASE DEPLOYMENT (PR)
      # ---------------------------
      - name: Checkout (needed for workspace consistency)
        uses: actions/checkout@v4

      - name: Install Azure CLI
        shell: bash
        run: |
          set -euo pipefail
          curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

      # azure/login is already handled inside deploy-to-aks, but we need az/kube access
      # so do an explicit login here as well
      - name: Azure login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Install kubectl (pinned)
        shell: bash
        run: |
          set -euo pipefail
          KUBECTL_VERSION="v1.29.8"
          curl -fsSLo kubectl "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl"
          sudo install -m 0755 kubectl /usr/local/bin/kubectl
          kubectl version --client=true

      - name: Install kubelogin (pinned)
        shell: bash
        run: |
          set -euo pipefail
          KUBELOGIN_VERSION="v0.1.6"
          curl -fsSLo kubelogin.zip "https://github.com/Azure/kubelogin/releases/download/${KUBELOGIN_VERSION}/kubelogin-linux-amd64.zip"
          unzip -q kubelogin.zip
          sudo install -m 0755 bin/linux_amd64/kubelogin /usr/local/bin/kubelogin
          kubelogin --version

      - name: Configure AKS credentials
        shell: bash
        run: |
          set -euo pipefail
          : "${AKS_RESOURCE_GROUP:?AKS_RESOURCE_GROUP is not set}"
          : "${AKS_CLUSTER_NAME:?AKS_CLUSTER_NAME is not set}"
          az aks get-credentials --overwrite-existing -g "${AKS_RESOURCE_GROUP}" -n "${AKS_CLUSTER_NAME}"
          kubelogin convert-kubeconfig -l azurecli

      - name: Download konduit.sh
        shell: bash
        run: |
          set -euo pipefail
          curl -fsSL https://raw.githubusercontent.com/DFE-Digital/teacher-services-cloud/main/scripts/konduit.sh \
            -o "$GITHUB_WORKSPACE/konduit.sh"
          chmod +x "$GITHUB_WORKSPACE/konduit.sh"
          ls -la "$GITHUB_WORKSPACE/konduit.sh"

      - name: Download seed backup from Blob
        shell: bash
        env:
          AZURE_STORAGE_CONNECTION_STRING: ${{ secrets.AZURE_STORAGE_CONNECTION_STRING }}
          AZURE_STORAGE_CONTAINER: ${{ secrets.AZURE_STORAGE_CONTAINER }} # school-data
        run: |
          set -euo pipefail
          BACKUP_BLOB="db-backups/sappub_review_seed_latest.sql.gz"
          BACKUP_FILE="seed.sql.gz"

          az storage blob download \
            --container-name "${AZURE_STORAGE_CONTAINER}" \
            --name "${BACKUP_BLOB}" \
            --file "${BACKUP_FILE}" \
            --connection-string "${AZURE_STORAGE_CONNECTION_STRING}" \
            --overwrite true

          ls -lh "${BACKUP_FILE}"

      - name: Install jq
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Ensure terraform vendor directory exists
        shell: bash
        run: |
          set -euo pipefail
          if [ -d "vendor" ]; then
            echo "vendor/ exists"
            ls -la vendor | head -50 || true
            exit 0
          fi

          echo "vendor/ missing. Checking for vendoring script..."
          if [ -x "./bin/vendor" ]; then
            ./bin/vendor
          elif [ -x "./script/vendor" ]; then
            ./script/vendor
          elif [ -f "Makefile" ] && grep -qE '^vendor:' Makefile; then
            make vendor
          else
            echo "vendor/ is required but no vendoring command was found in ./bin/vendor, ./script/vendor, or make vendor."
            echo "Repo root contents:"
            ls -la
            exit 1
          fi

          echo "vendor/ created:"
          ls -la vendor | head -50 || true

      - name: Read PR DB URL from terraform outputs
        id: prdb
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail

          sudo apt-get update
          sudo apt-get install -y jq

          TF_DIR="${GITHUB_WORKSPACE}/${TERRAFORM_BASE}"
          echo "Terraform dir: ${TF_DIR}"
          cd "${TF_DIR}"

          # Init (now safe because vendor/ exists)
          terraform init -input=false

          OUT_JSON="$(terraform output -json)"
          echo "${OUT_JSON}" | jq -r 'keys[]' | sed 's/^/terraform output key: /' || true

          CANDIDATES=(
            "database_url"
            "db_url"
            "postgres_url"
            "postgres_database_url"
            "app_database_url"
            "application_database_url"
            "review_database_url"
          )

          DB_URL=""
          for k in "${CANDIDATES[@]}"; do
            v="$(echo "${OUT_JSON}" | jq -r --arg k "$k" '.[$k].value // empty')"
            if [ -n "$v" ] && [ "$v" != "null" ]; then
              DB_URL="$v"
              echo "Selected terraform output: $k"
              break
            fi
          done

          if [ -z "$DB_URL" ]; then
            echo "DB_URL not found in terraform outputs (candidates tried: ${CANDIDATES[*]})."
            exit 0
          fi

          echo "DB_URL acquired (masked): $(echo "$DB_URL" | sed -E 's#(postgres(ql)?://)[^@]+@#\1****@#')"
          echo "db_url=$DB_URL" >> "$GITHUB_OUTPUT"

      - name: Restore backup into PR review DB
        continue-on-error: true
        shell: bash
        run: |
          set -euo pipefail
          : "${KONDUIT_NAMESPACE:?KONDUIT_NAMESPACE is not set}"
          : "${KONDUIT_APP_NAME:?KONDUIT_APP_NAME is not set}"

          BACKUP_FILE="seed.sql.gz"
          DB_URL="${{ steps.prdb.outputs.db_url }}"

          if [ -z "${DB_URL:-}" ]; then
            echo "DB_URL not available from terraform outputs; skipping restore for now."
            exit 0
          fi

          echo "Konduit tunnel app: ${KONDUIT_APP_NAME} (namespace: ${KONDUIT_NAMESPACE})"
          echo "Backup file:"
          ls -lh "${BACKUP_FILE}"
          gzip -t "${BACKUP_FILE}"

          # Readiness check (connect using provided DB URL)
          "$GITHUB_WORKSPACE/konduit.sh" \
            -n "${KONDUIT_NAMESPACE}" \
            -u "${DB_URL}" \
            -t 300 \
            -x \
            "${KONDUIT_APP_NAME}" -- psql -X -tAc "select 1"

          # Restore using the provided DB URL (no need to access PR deployment)
          "$GITHUB_WORKSPACE/konduit.sh" \
            -n "${KONDUIT_NAMESPACE}" \
            -u "${DB_URL}" \
            -t 7200 \
            -x \
            -i "${BACKUP_FILE}" -c \
            "${KONDUIT_APP_NAME}" -- psql -v ON_ERROR_STOP=1 -X

  # ---------------------------
  # DEPLOY TEST (AUTO) + PROD (MANUAL APPROVAL)
  # ---------------------------
  deploy:
    name: Deploy to Test and Production
    if: ${{ github.ref == 'refs/heads/main' && github.event_name == 'push' }}
    needs: [build, test]
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      pull-requests: write

    strategy:
      max-parallel: 1
      matrix:
        environment: [test, production]

    environment:
      name: ${{ matrix.environment }}
      url: ${{ steps.deploy_app.outputs.environment_url }}

    steps:
      - name: Deploy app to ${{ matrix.environment }}
        id: deploy_app
        uses: DFE-Digital/github-actions/deploy-to-aks@master
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          environment: ${{ matrix.environment }}
          sha: ${{ needs.build.outputs.docker-image-tag }}
          terraform-base: ${{ env.TERRAFORM_BASE }}
          healthcheck: ${{ env.HEALTHCHECK_CMD }}
          slack-webhook: ${{ secrets.SLACK_WEBHOOK }}
          smoke-test: false

  # ---------------------------
  # MANUAL DEPLOY
  # ---------------------------
  manual_deploy:
    name: Manual deploy
    if: ${{ github.event_name == 'workflow_dispatch' }}
    environment:
      name: ${{ inputs.environment }}
      url: ${{ steps.deploy_manual.outputs.environment_url }}
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      pull-requests: write

    steps:
      - name: Deploy app to ${{ inputs.environment }}
        id: deploy_manual
        uses: DFE-Digital/github-actions/deploy-to-aks@master
        with:
          azure-client-id: ${{ secrets.AZURE_CLIENT_ID }}
          azure-subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          azure-tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          environment: ${{ inputs.environment }}
          pr-number: ${{ inputs.pull-request-number }}
          sha: ${{ inputs.docker-image-tag }}
          terraform-base: ${{ env.TERRAFORM_BASE }}
          healthcheck: ${{ env.HEALTHCHECK_CMD }}
          slack-webhook: ${{ secrets.SLACK_WEBHOOK }}
          smoke-test: false
          db-seed: ${{ inputs.environment == 'review' && 'true' || 'false' }} 
